#!/usr/bin/env php
<?php

namespace Gentry;

use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use ReflectionClass;
use ReflectionMethod;
use zpt\anno\Annotations;
use Kingconf\Config;
use Kingconf\Exception;

/**
 * "Borrowed" from the PHPUnit executable.
 */

if (!ini_get('date.timezone')) {
    ini_set('date.timezone', 'UTC');
}

foreach ([
    __DIR__.'/../../autoload.php',
    __DIR__.'/../../vendor/autoload.php',
    __DIR__.'/../vendor/autoload.php',
    __DIR__.'/vendor/autoload.php',
] as $file) {
    if (file_exists($file)) {
        define('Gentry\COMPOSER_INSTALL', $file);
        break;
    }
}

unset($file);

if (!defined('Gentry\COMPOSER_INSTALL')) {
    fwrite(STDERR,
        'You need to set up the project dependencies using the following commands:'.PHP_EOL.
        'wget http://getcomposer.org/composer.phar'.PHP_EOL.
        'php composer.phar install'.PHP_EOL
    );
    die(1);
}

$autoloader = require COMPOSER_INSTALL;

$config = 'Gentry.json';
$verbose = false;
foreach ($argv as $i => $arg) {
    if (!$i) {
        continue; // ignore self
    }
    if ($arg == '-v') {
        $verbose = true;
    } else {
        $config = $arg;
    }
}
try {
    $config = (object)(array)(new Config($config));
} catch (Exception $e) {
    fwrite(STDERR,
        "Config file $config not found or invalid.".PHP_EOL
    );
    die(1);
}
if (isset($config->includePath)) {
    if (is_string($config->includePath)) {
        $config->includePath = explode(PATH_SEPARATOR, $config->includePath);
    }
    set_include_path(implode(PATH_SEPARATOR, $config->includePath)
        .PATH_SEPARATOR.get_include_path()
    );
}
if (isset($config->useIncludePath) && $config->useIncludePath) {
    $autoloader->setUseIncludePath(true);
}
if (!isset($config->base)) {
    $config->base = 'PHPUnit_Framework_Testcase';
}

// Grab all source files in specified directory:
$sources = [];
foreach (new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($config->src),
    RecursiveIteratorIterator::LEAVES_ONLY
) as $file) {
    // force compilation
    if ($file->isFile() && substr($file->getFilename(), -4) == '.php') {
        $filename = "$file";
        $code = file_get_contents($filename);
        if (preg_match("@(function|class)\s+\w+\s+@msi", $code)) {
            $sources[$filename] = [];
        }
        $ns = '';
        if (preg_match("@namespace ((\w|\\\\)+)@", $code, $match)) {
            $ns = $match[1].'\\';
        }
        $class = '';
        if (preg_match("@(class|trait)\s+(\w+)\s@", $code, $match)) {
            $class = $match[2].'::';
        }
        preg_match_all(
            "@function (\w+)\s*\(@",
            $code,
            $matches,
            PREG_SET_ORDER
        );
        foreach ($matches as $match) {
            if (substr($match[1], 0, 1) == '_') {
                // Assume we never want to test these "private" or magic
                // methods.
                continue;
            }
            $sources[$filename][] = "$ns$class{$match[1]}";
        }
    }
}
fwrite(STDOUT, sprintf(
    "Found %d files with possibly valid source code.".PHP_EOL,
    count($sources)
));

// Grab existing unit tests in specified directory:
$tests = [];
foreach (new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($config->tests),
    RecursiveIteratorIterator::LEAVES_ONLY
) as $file) {
    if ($file->isFile() && substr($file->getFilename(), -4) == '.php') {
        $filename = "$file";
        $code = file_get_contents($filename);
        if (preg_match("@class\s+(\w+Test)\s+extends@msi", $code, $match)) {
            $tests[$match[1]] = $filename;
        }
    }
}
fwrite(STDOUT, sprintf(
    "Found %d previously defined tests. Checking to see what's missing...".PHP_EOL,
    count($tests)
));

$coveredMethods = [];
$notcovered = 0;
foreach ($tests as $class => $file) {
    require_once $file;
    $reflection = new ReflectionClass($class);
    foreach ($reflection->getMethods() as $method) {
        if (substr($method->name, 0, 4) != 'test') {
            continue;
        }
        if ($method->class == $reflection->getName()) {
            $annotations = new Annotations($method);
            if (isset($annotations['covers'])) {
                $covers = $annotations['covers'];
                if (!is_array($covers)) {
                    $covers = [$covers];
                }
                $coveredMethods = array_merge($coveredMethods, $covers);
            } else {
                fwrite(STDERR, sprintf(
                    "WARNING: Test %s has method %s without @covers annotation.".PHP_EOL.
                    "You should first add that so we can analyze your existing tests.".PHP_EOL,
                    $method->class,
                    $method->name
                ));
                $notcovered++;
            }
        }
    }
}
$coveredMethods = array_unique($coveredMethods);
if ($notcovered) {
    die(1);
}

function normalizeMethod($method)
{
    return ucfirst(preg_replace('@.*?::@', '', $method));
}

$addMethodTo = function ($file, $method) use ($config) {
    static $tmpl = <<<EOT

    /**
     * @covers %1\$s
     */
    public function test%2\$s()
    {
        \$this->assertTrue(true);
        \$this->markTestIncomplete("Note: %1\$s has an empty test.");
    }


EOT;
    $class = str_replace("{$config->tests}/", '', $file);
    $class = str_replace('/', '', $class);
    $class = preg_replace('@\.php$@', '', $class);
    if (!file_exists($file)) {
        @mkdir(substr($file, 0, strrpos($file, '/')), 0755, true);
        file_put_contents($file, sprintf(
            <<<EOT
<?php

class %1\$s extends %2\$s
{
}

EOT
            ,
            $class,
            $config->base
        ));
    }
    $code = file_get_contents($file);
    $code = preg_replace(
        '@^}(\s*|\?>)?$@ms',
        sprintf(
            $tmpl,
            $method,
            normalizeMethod($method)
        ),
        $code
    );
    $code = trim($code)."\n}\n\n";
    $code = preg_replace("@^{\n\n    /\*@m", "{\n    /*", $code);
    file_put_contents($file, $code);
};

$getTestName = function ($file) use ($config) {
    $file = str_replace($config->src, $config->tests, $file);
    $file = preg_replace('@\.php$@', '', $file);
    return "{$file}Test.php";
};

foreach ($sources as $file => $methods) {
    foreach ($methods as $method) {
        if (!in_array($method, $coveredMethods)) {
            $addMethodTo($getTestName($file), $method);
        }
    }
}

