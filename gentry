#!/usr/bin/env php
<?php

namespace Gentry;

use Ansi;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use ReflectionClass;
use ReflectionMethod;
use Closure;
use zpt\anno\Annotations;
use Kingconf;
use Exception;

$start = microtime(true);
/**
 * "Borrowed" from the PHPUnit executable.
 */

if (!ini_get('date.timezone')) {
    ini_set('date.timezone', 'UTC');
}

function out($text, $out = STDOUT)
{
    $text = str_replace("\n", PHP_EOL, $text);
    echo Ansi::tagsToColors($text);
    echo Ansi::tagsToColors('<reset>');
}

foreach ([
    __DIR__.'/../../autoload.php',
    __DIR__.'/../../vendor/autoload.php',
    __DIR__.'/../vendor/autoload.php',
    __DIR__.'/vendor/autoload.php',
] as $file) {
    if (file_exists($file)) {
        define('Gentry\COMPOSER_INSTALL', $file);
        break;
    }
}

unset($file);

if (!defined('Gentry\COMPOSER_INSTALL')) {
    out(<<<EOT
<red>Error: <reset>You need to set up the project dependencies using the following commands:

<yellow>wget http://getcomposer.org/composer.phar
php composer.phar install

EOT
        ,
        STDERR
    );
    die(1);
}

$autoloader = require COMPOSER_INSTALL;

$config = 'Gentry.json';
$verbose = false;
$generate = false;
foreach ($argv as $i => $arg) {
    if (!$i) {
        continue; // ignore self
    }
    if ($arg == '-v') {
        $verbose = true;
    } elseif ($arg == '-g') {
        $generate = true;
    } else {
        $config = $arg;
    }
}
try {
    $config = (object)(array)(new Kingconf\Config($config));
} catch (Kingconf\Exception $e) {
    out("<red>Error: <reset> Config file $config not found or invalid.\n", STDERR);
    die(1);
}
if (isset($config->includePath)) {
    if (is_string($config->includePath)) {
        $config->includePath = explode(PATH_SEPARATOR, $config->includePath);
    }
    set_include_path(implode(PATH_SEPARATOR, $config->includePath));
    $autoloader->setUseIncludePath(true);
}
if (isset($config->bootstrap)) {
    $bootstrap = is_array($config->bootstrap) ? $config->bootstrap : [$config->bootstrap];
    foreach ($bootstrap as $file) {
        require $file;
    }
}

// Grab all source files in specified directory:
$sources = [];
foreach (new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($config->src),
    RecursiveIteratorIterator::LEAVES_ONLY
) as $file) {
    // force compilation
    if ($file->isFile() && substr($file->getFilename(), -4) == '.php') {
        $filename = realpath($file);
        $code = file_get_contents($filename);
        $ns = '';
        if (preg_match("@namespace ((\w|\\\\)+)@", $code, $match)) {
            $ns = $match[1].'\\';
        }
        $class = '';
        if (preg_match("@(class|trait)\s+(\w+)\s@", $code, $match)) {
            $class = $match[2];
        } else {
            continue;
        }
        if (!(preg_match_all(
            "@(?<!private|protected)\s*function\s+(\w+)\s*\(@",
            $code,
            $matches,
            PREG_SET_ORDER
        ))) {
            continue;
        }
        $sources[$filename] = ["$ns$class", []];
        foreach ($matches as $match) {
            if (substr($match[1], 0, 1) == '_') {
                // Assume we never want to test these "private" or magic
                // methods.
                continue;
            }
            $sources[$filename][1][] = $match[1];
        }
        if (!$sources[$filename][1]) {
            unset($sources[$filename]);
        }
    }
}
if ($verbose) {
    out(sprintf(
        "<gray>Found %d file%s with testable source code.\n",
        count($sources),
        count($sources) == 1 ? '' : 's'
    ));
}

// Grab existing tests in specified directory:
$tests = [];
foreach (new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($config->tests),
    RecursiveIteratorIterator::LEAVES_ONLY
) as $file) {
    if ($file->isFile() && substr($file->getFilename(), -4) == '.php') {
        $filename = realpath($file);
        $code = file_get_contents($filename);
        $ns = '';
        if (preg_match("@namespace ((\w|\\\\)+)@", $code, $match)) {
            $ns = $match[1].'\\';
        }
        if (preg_match("@(?<!abstract)\s*class\s+(\w+)\s+@msi", $code, $match)) {
            $class = "$ns{$match[1]}";
            $tests[$class] = $filename;
            require_once $filename;
    
        }
    }
}
if ($verbose) {
    out(sprintf(
        "<gray>Found %d previously defined test%s.\n",
        count($tests),
        count($tests) == 1 ? '' : 's'
    ));
}
if ($verbose && $tests) {
    out(sprintf(
        "<gray>Running existing unit test%...\n",
        count($tests == 1) ? '' : 's'
    ));
}

$coveredMethods = [];
$notcovered = 0;
$tested = 0;
$passed = 0;
$failed = 0;
$incomplete = 0;
foreach ($tests as $class => $file) {
    $class = new $class;
    $reflection = new ReflectionClass($class);
    $annotations = new Annotations($reflection);
    if (isset($annotations['Description'])) {
        out("<darkBlue>{$annotations['Description']}\n");
    }
    $wakeup = method_exists($class, '__wakeup') && $verbose ?
        new Annotations(new ReflectionMethod($class, '__wakeup')) :
        [];
    foreach ($reflection->getMethods(ReflectionMethod::IS_PUBLIC) as $method) {
        if ($method->name{0} == '_') {
            continue;
        }
        $tested++;
        $annotations = new Annotations($method);
        if (isset($annotations['Description'])) {
            out("  * <blue>{$annotations['Description']}");
        }
        if (isset($annotations['Incomplete'])) {
            out(" <cyan>[INCOMPLETE]\n");
            $incomplete++;
            continue;
        }
        if (method_exists($class, '__wakeup')) {
            if (isset($wakeup['Description'])) {
                out("    <gray>{$wakeup['Description']}\n");
            }
            $class->__wakeup();
        }
        $params = $method->getParameters();
        $args = [];
        $remote = [];
        foreach ($params as $i => $param) {
            if ($i == 0) {
                $type = $param->getClass();
                $args[] = isset($class->{$param->name})
                    && get_class($class->{$param->name}) == $type ?
                    $class->{$param->name} :
                    $type->newInstance();
            } elseif ($i == 1) {
                $methodname = $args[] = $param->name;
            } elseif ($param->isDefaultValueAvailable()) {
                $remote[] = $args[] = $param->getDefaultValue();
            } elseif (isset($class->{$param->name})) {
                $remote[] = $args[] = $class->{$param->name};
            } elseif ($type = $param->getClass()) {
                $remote[] = $args[] = $type->newInstance();
            } else {
                $remote[] = $args[] = null;
            }
        }
        $testclass = get_class($args[0]);
        if (!isset($coveredMethods[$testclass])) {
            $coveredMethods[$testclass] = [];
        }
        $coveredMethods[$testclass][] = $method->name;

        $expected = $actual = ['result' => null, 'thrown' => null];
        try {
            $expected['result'] = $method->invokeArgs($class, $args);
        } catch (Exception $e) {
            $expected['thrown'] = get_class($e);
        }
        try {
            $actual['result'] = call_user_func_array([$args[0], $args[1]], $remote);
        } catch (Exception $e) {
            $actual['thrown'] = get_class($e);
        }
        if (is_object($expected['result'])
            && $expected['result'] instanceof Closure
        ) {
            $fn = $expected['result'];
            $expected['result'] = true;
            $actual['result'] = call_user_func($fn, $actual['result']);
        }
        if (isset($annotations['Pipe'])) {
            $actual['result'] = call_user_func($annotations['Pipe'], $actual['result']);
        }
        if ($expected === $actual) {
            $passed++;
            out(" <green>[OK]\n");
        } else {
            out(" <red>[FAILED]<reset> ");
            $failed++;
            if ($expected['result'] !== $actual['result']) {
                out(sprintf(
                    "(expected <magenta>%s<reset>, got <magenta>%s<reset>)\n",
                    tostring($expected['result']),
                    tostring($actual['result'])
                ));
            } else {
                out(sprintf(
                    "(wanted to catch {$expected['thrown']}, got %s)\n",
                    isset($expected['result']) ? tostring($expected['result']) : $actual['thrown']
                ));
            }
        }
        if (method_exists($class, '__sleep')) {
            $class->__sleep();
        }
    }
    unset($class);
}
if ($passed) {
    out(sprintf(
        "<green>%d test%s passed.\n",
        $passed,
        $passed == 1 ? '' : 's'
    ));
}
if ($failed) {
    out(sprintf(
        "<red>%d test%s failed!\n",
        $failed,
        $failed == 1 ? '' : 's'
    ), STDERR);
}
if ($incomplete) {
    out(sprintf(
        "<magenta>%d test%s marked as incomplete.\n",
        $incomplete,
        $incomplete == 1 ? '' : 's'
    ), STDERR);
}

function tostring($value)
{
    if (!isset($value)) {
        return 'NULL';
    }
    if ($value === true) {
        return 'true';
    }
    if ($value === false) {
        return 'false';
    }
    if (is_scalar($value)) {
        return $value;
    }
    if (is_array($value)) {
        return 'array';
    }
    if (is_object($value)) {
        return get_class($value);
    }
}

$classes = 0;
$methods = 0;
$uncovered = [];
foreach ($sources as $file => $code) {
    if (!isset($coveredMethods[$code[0]])) {
        $classes++;
        $methods += count($code[1]);
        $uncovered[$code[0]] = $code[1];
    } else {
        foreach ($code[1] as $method) {
            if (!in_array($method, $coveredMethods[$code[0]])) {
                $methods++;
                if (!isset($uncovered[$code[0]])) {
                    $uncovered[$code[0]] = [];
                }
                $uncovered[$code[0]][] = $method;
            }
        }
    }
}
if ($classes) {
    out(sprintf(
        "<cyan>Missing %d class scenario%s.\n",
        $classes,
        $classes == 1 ? '' : 's'
    ));
}
if ($methods) {
    out(sprintf(
        "<cyan>Missing (at least) %d method test%s.\n",
        $methods,
        $methods == 1 ? '' : 's'
    ));
}

$endit = function ($code) use ($start) {
    out(sprintf(
        "Took %0.2f seconds.\n\n",
        microtime(true) - $start
    ));
    die($code);
};
if ($classes || $methods) {
    if (!$generate && $verbose) {
        out("<gray>Run with <magenta>-g<gray> flag to generate skeletons.\n");
        $endit($failed ? 1 : 0);
    }
} else {
    $endit($failed ? 1 : 0);
}

if ($verbose) {
    out("<gray>Generating test skeletons as requested...\n");
}

$sourceToTestName = function ($file) use ($config) {
    return str_replace($config->src, $config->tests, $file);
};

foreach ($sources as $file => $code) {
    if (!isset($uncovered[$code[0]])) {
        continue;
    }
    $target = $sourceToTestName($file);
    if (file_exists($target)) {
        $base = file_get_contents($target);
    } else {
        $base = "<?php\n\n";
        if (isset($config->namespace)) {
            $base .= "namespace {$config->namespace};\n\n";
        }
        $base .= <<<EOT
/**
 * @Description [GENERATED] Test {$code[0]}
 */

EOT;
        $base .= 'class '.str_replace('\\', '', $code[0])."\n";
        $base .= <<<EOT
{
}

EOT;
    }
    var_dump($base);
}
/*
if ($notcovered) {
    die(1);
}

function normalizeMethod($method)
{
    return ucfirst(preg_replace('@.*?::@', '', $method));
}

$addMethodTo = function ($file, $method) use ($config) {
    static $tmpl = <<<EOT

    /**
     * @covers %1\$s
    public function test%2\$s()
    {
        \$this->assertTrue(true);
        \$this->markTestIncomplete("Note: %1\$s has an empty test.");
    }


EOT;
    $class = str_replace("{$config->tests}/", '', $file);
    $class = str_replace('/', '', $class);
    $class = preg_replace('@\.php$@', '', $class);
    if (!file_exists($file)) {
        @mkdir(substr($file, 0, strrpos($file, '/')), 0755, true);
        file_put_contents($file, sprintf(
            <<<EOT
<?php

class %1\$s extends %2\$s
{
}

EOT
            ,
            $class,
            $config->base
        ));
    }
    $code = file_get_contents($file);
    $code = preg_replace(
        '@^}(\s*|\?>)?$@ms',
        sprintf(
            $tmpl,
            $method,
            normalizeMethod($method)
        ),
        $code
    );
    $code = trim($code)."\n}\n\n";
    $code = preg_replace("@^{\n\n    /\*@m", "{\n    /*", $code);
    file_put_contents($file, $code);
};

$getTestName = function ($file) use ($config) {
    $file = str_replace($config->src, $config->tests, $file);
    $file = preg_replace('@\.php$@', '', $file);
    return "{$file}Test.php";
};

foreach ($sources as $file => $methods) {
    foreach ($methods as $method) {
        if (!in_array($method, $coveredMethods)) {
            $addMethodTo($getTestName($file), $method);
        }
    }
}
*/
