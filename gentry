#!/usr/bin/env php
<?php

namespace Gentry;

use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use zpt\anno\Annotations;

/**
 * "Borrowed" from the PHPUnit executable.
 */

if (!ini_get('date.timezone')) {
    ini_set('date.timezone', 'UTC');
}

foreach ([
    __DIR__.'/../../autoload.php',
    __DIR__.'/../../vendor/autoload.php',
    __DIR__.'/../vendor/autoload.php',
    __DIR__.'/vendor/autoload.php',
] as $file) {
    if (file_exists($file)) {
        define('Gentry\COMPOSER_INSTALL', $file);
        break;
    }
}

unset($file);

if (!defined('Gentry\COMPOSER_INSTALL')) {
    fwrite(STDERR,
        'You need to set up the project dependencies using the following commands:'.PHP_EOL.
        'wget http://getcomposer.org/composer.phar'.PHP_EOL.
        'php composer.phar install'.PHP_EOL
    );
    die(1);
}

$autoloader = require COMPOSER_INSTALL;

$config = 'Gentry.json';
$verbose = false;
foreach ($argv as $i => $arg) {
    if ($arg == '-v') {
        $verbose = true;
    } else {
        $config = $arg;
    }
}
if (!file_exists($config)) {
    fwrite(STDERR,
        "Config file $config not found.".PHP_EOL
    );
    die(1);
}
    
$autoloader->setUseIncludePath(true);
foreach (new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($tplDir),
    RecursiveIteratorIterator::LEAVES_ONLY
) as $file) {
    // force compilation
    if ($file->isFile() && substr($file->getFilename(), -10) == '.html.twig') {
        $twig->loadTemplate(str_replace($tplDir.'/', '', $file));
    }
}
require 'src/parseArgs.php';
$arguments = parseArgs($argv);

$usage = str_replace("\n", PHP_EOL, <<<EOT

PHP Unit test generation tool

Usage:
./gentry command --code path/to/code --tests path/to/tests

Commands:
- test: Test coverage and output analysis results.
- dryrun: Generate tests for all missing classes/methods but dump to STDOUT.
- add: Generate tests for all missing classes/methods and write to file.

Options:
--code|-c Path to code files, relative to cwd [required]
--tests|-t Path to test classes, relative to cwd [required]
--base|-b Optional base class [defaults to PHPUnit_Framework_TestCase]
--include_path|-i Optional include path to use
--prepend|-p Optional PHP file to prepend (e.g. custom autoloader)
--strip|-s Optional regular expression to strip from the beginning of paths.
           This is useful if you rely on include_path to override classes.
--verbose|-v Be verbose. Useful to catch errors.

EOT
);

// Map short to long arguments for consistency:
$args = [];
if (isset($arguments[0])) {
    $args[0] = $arguments[0];
}
foreach ([
    'c' => 'code',
    't' => 'tests',
    'b' => 'base',
    'i' => 'include_path',
    'p' => 'prepend',
    's' => 'strip',
    'v' => 'verbose',
] as $key => $value) {
    if (isset($arguments[$key])) {
        $args[$value] = $arguments[$key];
    } elseif (isset($arguments[$value])) {
        $args[$value] = $arguments[$value];
    }
}
if (!isset($args[0], $args['code'], $args['tests'])
    || !in_array($args[0], ['test', 'add', 'dryrun'])
) {
    fwrite(STDERR, $usage);
    die(1);
}
$cwd = getcwd();
foreach (['code', 'tests'] as $param) {
    if ($args[$param]{0} != '.') {
        if ($args[$param]{0} == '/') {
            $args[$param] = substr($args[$param], 1);
        }
        $args[$param] = "$cwd/{$args[$param]}";
    }
}
if (isset($args['include_path'])) {
    set_include_path($args['include_path']);
}
set_include_path(get_include_path().PATH_SEPARATOR.$args['tests']);
if (isset($args['prepend'])) {
    include $args['prepend'];
}

fwrite(STDOUT, "Analysing existing unit tests...".PHP_EOL);
$coveredMethods = [];
$covered = 0;
$notcovered = [];
$testfiles = Walker::walk($args['tests'], function ($reflection) use (&$coveredMethods, &$covered, &$notcovered) {
    foreach ($reflection->getMethods() as $method) {
        if (substr($method->name, 0, 4) != 'test') {
            continue;
        }
        if ($method->class == $reflection->getName()) {
            $annotations = new Annotations($method);
            if (isset($annotations['covers'])) {
                $covers = $annotations['covers'];
                if (!is_array($covers)) {
                    $covers = [$covers];
                }
                foreach ($covers as $cover) {
                    $parts = explode('::', $cover);
                    if (!isset($coveredMethods[$parts[0]])) {
                        $coveredMethods[$parts[0]] = [];
                    }
                    if (!isset($coveredMethods[$parts[0]][$parts[1]])) {
                        $coveredMethods[$parts[0]][$parts[1]] = true;
                        $covered++;
                    }
                }
            } else {
                $notcovered[] = "{$method->class}::{$method->name}";
            }
        }
    }
}, isset($args['strip']) ? $args['strip'] : null, isset($args['verbose']));
fwrite(STDOUT, "Ok, ".$covered." class methods currently covered.".PHP_EOL);
if (count($notcovered)) {
    fwrite(STDOUT, "Additionally, ".count($notcovered)." method tests were found w/o @covers annotation. Fix those first.".PHP_EOL);
    fwrite(STDOUT, "    Annotate these test methods:".PHP_EOL);
    foreach ($notcovered as $method) {
        fwrite(STDOUT, "    - $method".PHP_EOL);
    }
}
fwrite(STDOUT, "Analysing existing code base...".PHP_EOL);
$suppliedMethods = [];
$missing = 0;
Walker::walk($args['code'], function ($reflection) use (&$suppliedMethods, $coveredMethods, $args, &$missing) {
    if (strpos($reflection->getFileName(), $args['code']) !== 0) {
        return;
    }
    foreach ($reflection->getMethods() as $method) {
        if (substr($method->name, 0, 1) == '_') {
            // Assume we never want to test these "private" or magic methods.
            continue;
        }
        if ($method->getFileName() != $reflection->getFileName()) {
            // Assume we only want to test for "base level" methods.
            // If you really need to test methods inherited from some abstract
            // base class or a trait, add tests manually. Sorry. :)
            continue;
        }
        if ($method->isPublic()) {
            if (!isset($coveredMethods[$method->class][$method->name])) {
                if (!isset($suppliedMethods[$method->class])) {
                    $suppliedMethods[$method->class] = [];
                }
                $missing++;
                $suppliedMethods[$method->class][$method->name] = true;
            }
        }
    }
}, isset($args['strip']) ? $args['strip'] : null, isset($args['verbose']));
fwrite(STDOUT, "Currently missing tests for ".$missing." class methods in ".count($suppliedMethods)." classes.".PHP_EOL);
if (count($notcovered)) {
    fwrite(STDOUT, "Aborting due to unannotated existing tests.".PHP_EOL);
    die(1);
}
if ($missing) {
    if ($args[0] == 'test') {
        fwrite(STDOUT, "Run gentry dryrun -c=... -t=... [-b|s|v|i=...] to review what we'll try to generate.".PHP_EOL);
        fwrite(STDOUT, "Run gentry add -c=... -t=... [-b|s|v|i=...] to generate skeletons.".PHP_EOL);
        die(0);
    } else {
        $tpl = <<<EOT
<?php

class %1\$s
{%2\$s}


EOT;
        $base = isset($args['base']) ? $args['base'] : 'PHPUnit_Framework_TestCase';
        foreach ($suppliedMethods as $class => $methods) {
            $parts = explode('\\', $class);
            $testclass = array_pop($parts).'Test';
            $code = [];
            foreach ($methods as $method => $dummy) {
                if (isset($coveredMethods[$class])) {
                    if (!isset($coveredMethods[$class][$method])) {
                        fwrite(STDOUT, "Warning: {$testclass} exists, but does not yet cover {$method}.".PHP_EOL);
                    }
                }
                $fname = ucfirst($method);
                $code[] = <<<EOT
    /**
     * @covers $class::$method
     */
    public function test{$fname}()
    {
        \$this->assertTrue(true);
        \$this->markTestIncomplete("Note: $class::$method has an empty test.");
    }
EOT;
            }
            $gen = sprintf(
                $tpl,
                implode('', $parts).$testclass.' extends '.$base,
                $code ? "\n".implode("\n\n", $code)."\n" : ''
            );
            if ($args[0] == 'add') {
                if (isset($coveredMethods[$class])) {
                    fwrite(STDOUT, "Warning: {$testclass} exists, so not overwriting. Use gentry dryrun to see generated code.".PHP_EOL);
                    continue;
                }
                @mkdir($args['tests'].'/'.implode('/', $parts), 0755, true);
                file_put_contents(
                    $args['tests'].'/'.implode('/', $parts).'/'.$testclass.'.php',
                    $gen
                );
            } elseif ($args[0] == 'dryrun') {
                fwrite(STDOUT, PHP_EOL."File: ".implode('/', $parts).'/'.$testclass.'.php'.PHP_EOL.$gen.PHP_EOL);
            }
        }
    }
}

