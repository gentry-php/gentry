#!/usr/bin/env php
<?php

namespace Gentry;

use Ansi;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use ReflectionClass;
use ReflectionMethod;
use ReflectionException;
use Closure;
use zpt\anno\Annotations;
use Kingconf;
use Exception;

$start = microtime(true);

if (!ini_get('date.timezone')) {
    ini_set('date.timezone', 'UTC');
}

require __DIR__.'/src/helpers.php';

foreach ([
    __DIR__.'/../../autoload.php',
    __DIR__.'/../../vendor/autoload.php',
    __DIR__.'/../vendor/autoload.php',
    __DIR__.'/vendor/autoload.php',
] as $file) {
    if (file_exists($file)) {
        define('Gentry\COMPOSER_INSTALL', $file);
        break;
    }
}

unset($file);

if (!defined('Gentry\COMPOSER_INSTALL')) {
    out(<<<EOT
<red>Error: <reset>You need to set up the project dependencies using the following commands:

<yellow>wget http://getcomposer.org/composer.phar
php composer.phar install

EOT
        ,
        STDERR
    );
    die(1);
}

$autoloader = require COMPOSER_INSTALL;

out("\n<magenta>Gentry 0.3.3 by Marijn Ophorst\n\n");

$config = 'Gentry.json';
$verbose = false;
$generate = false;
foreach ($argv as $i => $arg) {
    if (!$i) {
        continue; // ignore self
    }
    if ($arg == '-v') {
        $verbose = true;
    } elseif ($arg == '-g') {
        $generate = true;
    } else {
        $config = $arg;
    }
}
try {
    $config = (object)(array)(new Kingconf\Config($config));
} catch (Kingconf\Exception $e) {
    out("<red>Error: <reset> Config file $config not found or invalid.\n", STDERR);
    die(1);
}
if (isset($config->includePath)) {
    if (is_string($config->includePath)) {
        $config->includePath = explode(PATH_SEPARATOR, $config->includePath);
    }
    set_include_path(implode(PATH_SEPARATOR, $config->includePath));
    $autoloader->setUseIncludePath(true);
}
if (isset($config->bootstrap)) {
    $bootstrap = is_array($config->bootstrap) ? $config->bootstrap : [$config->bootstrap];
    foreach ($bootstrap as $file) {
        require $file;
    }
}

// Grab all source files in specified directory:
$sources = [];
foreach (new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($config->src),
    RecursiveIteratorIterator::LEAVES_ONLY
) as $file) {
    if ($file->isFile() && substr($file->getFilename(), -4) == '.php') {
        $filename = realpath($file);
        $code = file_get_contents($filename);
        $code = preg_replace("@/\*\*.*?\*/@ms", '', $code);
        $ns = '';
        if (preg_match("@namespace ((\w|\\\\)+)@", $code, $match)) {
            $ns = $match[1].'\\';
        }
        $class = '';
        if (preg_match("@(class|trait)\s+(\w+)\s@", $code, $match)) {
            $class = $match[2];
        } else {
            continue;
        }
        if (!(preg_match_all(
            "@(?<!private|protected)\s*function\s+(\w+)\s*\(@",
            $code,
            $matches,
            PREG_SET_ORDER
        ))) {
            continue;
        }
        if (isset($config->ignore)
            && preg_match("@{$config->ignore}@", "$ns$class")
        ) {
            continue;
        }
        $reflection = new ReflectionClass("$ns$class");
        if ($reflection->isAbstract()) {
            continue;
        }
        $annotations = new Annotations($reflection);
        if (isset($annotations['Untestable'])) {
            continue;
        }
        $methods = [];
        foreach ($reflection->getMethods(ReflectionMethod::IS_PUBLIC) as $method) {
            $annotations = new Annotations($method);
            if (isset($annotations['Untestable'])) {
                continue;
            }
            if ($method->isInternal()) {
                continue;
            }
            if ($method->getDeclaringClass()->name != "$ns$class") {
                continue;
            }
            if ($method->name{0} == '_') {
                // Assume we never want to test these "private" or magic
                // methods.
                continue;
            }
            $doccomments = $method->getDocComment();
            if ($doccomments
                && preg_match('/@return ([\w|]*?)\s/ms', $doccomments, $returns)
            ) {
                $methods[] = $method;
            } elseif ($verbose) {
                out("<gray>$ns$class::{$method->name} should annotate its @return value.\n");
            }
        }
        if ($methods) {
            $sources[$filename] = ["$ns$class", $methods];
        }
    }
}
if ($verbose) {
    out(sprintf(
        "<gray>Found %d file%s with testable source code.\n",
        count($sources),
        count($sources) == 1 ? '' : 's'
    ));
}

// Grab existing tests in specified directory:
$tests = [];
foreach (new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($config->tests),
    RecursiveIteratorIterator::LEAVES_ONLY
) as $file) {
    if ($file->isFile() && substr($file->getFilename(), -4) == '.php') {
        $filename = realpath($file);
        $code = file_get_contents($filename);
        $code = preg_replace("@/\*\*.*?\*/@ms", '', $code);
        $ns = '';
        if (preg_match("@namespace ((\w|\\\\)+)@", $code, $match)) {
            $ns = $match[1].'\\';
        }
        if (preg_match("@class\s+(\w+)\s+@msi", $code, $match)) {
            $class = "$ns{$match[1]}";
            try {
                $reflection = new ReflectionClass($class);
                $annotations = new Annotations($class);
                if (!$reflection->isAbstract()) {
                    $tests[$class] = $filename;
                }
            } catch (ReflectionException $e) {
                out("<magenta>Warning: <gray>".$e->getMessage()."\n");
            }
        }
    }
}
if ($verbose) {
    out(sprintf(
        "<gray>Found %d previously defined test%s.\n",
        count($tests),
        count($tests) == 1 ? '' : 's'
    ));
}
if ($verbose && $tests) {
    out(sprintf(
        "<gray>Running existing unit test%...\n",
        count($tests == 1) ? '' : 's'
    ));
}

$coveredMethods = [];
$notcovered = 0;
$tested = 0;
$passed = 0;
$failed = [];
$incomplete = 0;
foreach ($tests as $class => $file) {
    $class = new $class;
    $reflection = new ReflectionClass($class);
    $annotations = new Annotations($reflection);
    $ok = false;
    foreach ($reflection->getMethods(ReflectionMethod::IS_PUBLIC) as $method) {
        $anns = new Annotations($method);
        if (!isset($anns['Incomplete'])) {
            $ok = true;
        } else {
            $incomplete++;
        }
    }
    if (!$ok && !$verbose) {
        continue;
    }
    if (isset($annotations['Feature'])) {
        out("<darkBlue>{$annotations['Feature']}\n");
    }
    $wakeup = method_exists($class, '__wakeup') && $verbose ?
        new Annotations(new ReflectionMethod($class, '__wakeup')) :
        [];
    foreach ($reflection->getMethods(ReflectionMethod::IS_PUBLIC) as $method) {
        if ($method->name{0} == '_') {
            continue;
        }
        $tested++;
        $test = new Test($class, $method);
        $annotations = new Annotations($method);
        if (!isset($annotations['Incomplete'])) {
            if (method_exists($class, '__wakeup')) {
                if (isset($wakeup['Description']) && $verbose) {
                    out("    <gray>({$wakeup['Description']})\n");
                }
                $class->__wakeup();
            }
        }
        $args = $test->run($passed, $failed);
        $features = $test->getTestedFeatures();
        foreach ($features as $target => $feature) {
            if (!isset($coveredMethods[$target])) {
                $coveredMethods[$target] = [];
            }
            if (!in_array($feature, $coveredMethods[$target])) {
                $coveredMethods[$target][] = $feature;
            }
        }

        if (method_exists($class, '__sleep')
            && !isset($annotations['Chain'])
        ) {
            $class->__sleep();
        }
    }
    unset($class);
}
out("\n");
if ($passed) {
    out(sprintf(
        "<green>%d test%s passed.\n",
        $passed,
        $passed == 1 ? '' : 's'
    ));
}
if ($incomplete) {
    out(sprintf(
        "<magenta>%d test%s marked as incomplete.\n",
        $incomplete,
        $incomplete == 1 ? '' : 's'
    ), STDERR);
}
if ($failed) {
    out(sprintf(
        "<red>%d test%s failed!\n",
        count($failed),
        count($failed) == 1 ? '' : 's'
    ), STDERR);
    foreach ($failed as $msg) {
        out("$msg\n");
    }
}

$classes = 0;
$methods = 0;
$uncovered = [];
foreach ($sources as $file => $code) {
    if (!isset($coveredMethods[$code[0]])) {
        $classes++;
        $methods += count($code[1]);
        $uncovered[$code[0]] = $code[1];
    } else {
        foreach ($code[1] as $method) {
            if (!in_array($method, $coveredMethods[$code[0]])) {
                $methods++;
                if (!isset($uncovered[$code[0]])) {
                    $uncovered[$code[0]] = [];
                }
                $uncovered[$code[0]][] = $method;
            }
        }
    }
}
if ($classes) {
    out(sprintf(
        "<cyan>Missing %d class scenario%s.\n",
        $classes,
        $classes == 1 ? '' : 's'
    ));
}
if ($methods) {
    out(sprintf(
        "<cyan>Missing (at least) %d method test%s.\n",
        $methods,
        $methods == 1 ? '' : 's'
    ));
}

$endit = function ($code) use ($start) {
    out(sprintf(
        "\n<magenta>Took %0.2f seconds, memory usage %4.2fMb.\n\n",
        microtime(true) - $start,
        memory_get_peak_usage(true) / 1048576
    ));
    exit($code);
};
if ($classes || $methods) {
    if (!$generate && $verbose) {
        out("<gray>Run with <magenta>-g<gray> flag to generate skeletons.\n");
        $endit($failed ? 1 : 0);
    }
}
if (!($classes || $methods) || !$generate) {
    $endit($failed ? 1 : 0);
}

if ($verbose) {
    out("<gray>Generating test skeletons as requested...\n");
}

$sourceToTestName = function ($file) use ($config) {
    return str_replace($config->src, $config->tests, $file);
};

foreach ($sources as $file => $code) {
    if (!isset($uncovered[$code[0]])) {
        continue;
    }
    $target = $sourceToTestName($file);
    if (strpos($code[0], '\\')) {
        $targetname = substr($code[0], strrpos($code[0], '\\') + 1);
    } else {
        $targetname = $code[0];
    }
    if (file_exists($target)) {
        $base = file_get_contents($target);
    } else {
        $base = "<?php\n\n";
        if (isset($config->namespace)) {
            $base .= "namespace {$config->namespace};\n\n";
        }
        if (strpos($code[0], '\\')) {
            $base .= "use {$code[0]};\n\n";
        }
        $targetvar = strtolower($targetname);
        $base .= <<<EOT
/**
 * @Feature [GENERATED] Test {$code[0]}
 */

EOT;
        $base .= 'class '.str_replace('\\', '', $code[0])."\n";
        $base .= <<<EOT
{
}

EOT;
    }
    $generatedMethods = [];
    foreach ($code[1] as $methodname) {
        if ($verbose) {
            out("<gray>Adding skeleton for $targetname::$methodname.\n");
        }
        if (strpos($base, "function $methodname(") === false) {
            $arguments = '';
            $generatedMethods[] = <<<EOT
    /**
     * @Scenario [GENERATED] Test {$code[0]}::$methodname
     * @Incomplete
     */
    public function $methodname($targetname $$targetvar$arguments)
    {
    }
EOT;
        }
    }
    $output = preg_replace(
        '@^}\s*$@m',
        implode("\n\n", $generatedMethods)."\n}\n",
        $base
    );
    $output = preg_replace(
        '@^{\n\n@m',
        "{\n",
        $output
    );
    if ($verbose) {
        out("<gray>Writing $target.\n");
    }
    $dir = dirname($target);
    @mkdir($dir, 0755, true);
    file_put_contents($target, $output);
}
/*
if ($notcovered) {
    die(1);
}

function normalizeMethod($method)
{
    return ucfirst(preg_replace('@.*?::@', '', $method));
}

$addMethodTo = function ($file, $method) use ($config) {
    static $tmpl = <<<EOT

    /**
     * @covers %1\$s
    public function test%2\$s()
    {
        \$this->assertTrue(true);
        \$this->markTestIncomplete("Note: %1\$s has an empty test.");
    }


EOT;
    $class = str_replace("{$config->tests}/", '', $file);
    $class = str_replace('/', '', $class);
    $class = preg_replace('@\.php$@', '', $class);
    if (!file_exists($file)) {
        @mkdir(substr($file, 0, strrpos($file, '/')), 0755, true);
        file_put_contents($file, sprintf(
            <<<EOT
<?php

class %1\$s extends %2\$s
{
}

EOT
            ,
            $class,
            $config->base
        ));
    }
    $code = file_get_contents($file);
    $code = preg_replace(
        '@^}(\s*|\?>)?$@ms',
        sprintf(
            $tmpl,
            $method,
            normalizeMethod($method)
        ),
        $code
    );
    $code = trim($code)."\n}\n\n";
    $code = preg_replace("@^{\n\n    /\*@m", "{\n    /*", $code);
    file_put_contents($file, $code);
};

$getTestName = function ($file) use ($config) {
    $file = str_replace($config->src, $config->tests, $file);
    $file = preg_replace('@\.php$@', '', $file);
    return "{$file}Test.php";
};

foreach ($sources as $file => $methods) {
    foreach ($methods as $method) {
        if (!in_array($method, $coveredMethods)) {
            $addMethodTo($getTestName($file), $method);
        }
    }
}
*/
